## 前置基础知识

### 1.Python中的保留字（关键字）

```python
>>> import keyword
>>> keyword.kwlist
['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
```

### 2.sys输出字符长度

```python
>>> import sys
>>> sys.stdout.write(" hi ")    # hi 前后各有 1 个空格
 hi 4
```

### 3.print输出

```python
# print 输出默认是换行的 如果要实现不换行需要在变量末尾加上 end=""：

x="a"
y="b"
# 换行输出
print( x )
print( y )
 
print('---------')
# 不换行输出
print( x, end=" " )
print( y, end=" " )
print()

# 结果
a
b
---------
a b
```

### 4.import 与 from...import


在 python 用 **import** 或者 **from...import** 来导入相应的模块。

将整个模块(somemodule)导入，格式为： **import somemodule**

从某个模块中导入某个函数,格式为： **from somemodule import somefunction**

从某个模块中导入多个函数,格式为： **from somemodule import firstfunc, secondfunc, thirdfunc**

将某个模块中的全部函数导入，格式为： **from somemodule import \***

```python
# 导入sys模块
import sys
print('================Python import mode==========================')
print ('命令行参数为:')
for i in sys.argv:
    print (i)
print ('\n python 路径为',sys.path)

# 导入 sys 模块的 argv,path 成员
from sys import argv,path  #  导入特定的成员
 
print('================python from import===================================')
print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path
```

### 5.args命令行参数

```python
getopt.getopt(args, shortopts, longopts=[])
```

**三个参数：**

-  **args**: 这个很清楚，就是参数列表。直接把 sys.args[1:] 切片传进来就可以。
-  **shortopts**: 这个参数是个字符串，把需要解析的“短选项”挨着写在一起就可以，这里的“短选项”指的是以 '-' 开头的选项，叫短选项是因为这种选项只支持单个字母，就算你写 -test 这样子的参数，能被 getopt 识别出来的也是 -t 和 est，其中 est 会被当作 -t 选项的参数。所以假设你想支持 “-h -i -o” 三个短选项， shortopts 就可以写成 “hio”。如果其中某个短选项想要接受参数，比如 "-h -i inputfile -o outputfile"，那就需要在字母后面加 ":" 冒号，变成 "hi:o:"
-  **longopts=[]**: 这个参数是个列表，因为每个长选项有多个字母，不可能像短选项一样用一个字符串就都表示出来。所谓长选项，就是以 “--” 开头的选项，比如 --usr --ifile --ofile 等，传参的时候写成 ['--user', '--ifile', '--ofile']，如果某个选项需要接受参数，则在后面加 "=" 等号，比如 ['--user', '--ifile=', '--ofile=']。

**返回值，有两个：**

-  **opts**：是有一个列表，列表里是元组（opt, value）的格式。比如上面的 "-h -i inputfile -o outputfile" 那就是 [('-h', ''), ('-i', 'inputfile'), ('-o', 'outputfile')] 这样的返回值。长选项和短选项以及各自的参数都会按先后次序放在这里。用的时候可以以 for opt,val in opts: 这样的方式来遍历。值得注意的是，返回的 opt 里面，'-' 和 '--' 都被保留下来了，另外，当用户输入的长选项没有写完的时候，会被自动补全。比如用户输入的是 --u，通过 getopt 会被自动补全成 --user，这个需要注意（除非有两个长选项都有相同的开头，无法确定是哪个）。
-  **args**：如果用户输入的信息太多，除了长选项和短选项以及各自选项的参数以外，还有一些其它的未知的参数，则会被放到这里。 看了这些，再去看上面的例子，相信会清楚很多了

## 字符串与变量

### **1.print() 里面加r代表输出的都为字符串**

![1](\图片\1.png)

### **2.三个“”里面可以放长段文字，并且保持格式不变**

![2](.\图片\2.png)

### **3.比较符号**

![3](.\图片\3.png)

### **4.系统生成随机数种子**

```python
x = random.getstate()
>>> print(x)

>>> random.randint(1,10)
6
>>> random.randint(1,10)
10
>>> random.randint(1,10)
4
>>> random.randint(1,10)
5
>>> random.randint(1,10)
10
>>> random.randint(1,10)
6
>>> random.randint(1,10)
3
>>> random.randint(1,10)
1
>>> random.randint(1,10)
9
>>> random.randint(1,10)
6


>>> random.setstate(x)
>>> random.randint(1,10)
6
>>> random.randint(1,10)
10
>>> random.randint(1,10)
4
>>> random.randint(1,10)
5
```

### 5.打印快捷方式

```python
print("每天爱玲宝三千遍" * 3000)
```

### 6.快速互换数值方式

```pyhon
x,y=y,x
```

### 7.生成随机数

```python
import random
random.randint(1,10)
//生成1-10之间的随机整数
```



## 数字

### **1.类型**

#### 整数 integers

#### 浮点数 floating point numbers

```python
>>> 0.1 + 0.2
0.30000000000000004
>>> i = 100
>>> i = 0
>>> while i<1:
	i=i+0.1
	print(i)

	
0.1
0.2
0.30000000000000004
0.4
0.5
0.6
0.7
0.7999999999999999
0.8999999999999999
0.9999999999999999
1.0999999999999999

>>> 0.3==0.1+0.2
False
>>> 0.3>0.1+0.2
False
>>> 0.3<0.1+0.2
True
```

```python
//生成精确数字
>>> import decimal
>>> a = decimal.Decimal('0.1')
>>> b = decimal.Decimal('0.2')
>>> print(a+b)
0.3

>>> c =decimal.Decimal('0.3')
>>> a + b == c
True
```

```python
//自动采用科学计数法
>>> 0.0000005
5e-07
```

#### 复数 complex numbers

```python
>>> 1+2j
(1+2j)
>>> x = 1+2j
//查询复数的实部(浮点数形式)
>>> x.real
1.0
//查询复数的虚部(浮点数形式)
>>> x.imag
2.0
```

### 2. 操作

![4](.\图片\4.png)

#### *** x // y 地板除（向下取整）***

```python
>>> 3/2
1.5
>>> 3//2
1
>>> -3//2
-2
```

#### ***x % y(取余)***

```python
>>> 3%2
1
>>> 6%2
0
```

**X == (x // y) * y + (x % y)**

#### ***divmod(x,y) 同时求出地板除结果和取余结果***

```python
>>> divmod(3,2)
(1, 1)
>>> divmod(10,3)
(3, 1)
>>> divmod(-3,2)
(-2, 1)
```

#### ***abs()求绝对值***(复数求模)

```python
>>> x = -520
>>> y = abs(x)
>>> y
520
>>> z = 234
>>> abs(z)
234
>>> i = 1+2j
>>> abs(i)
2.23606797749979
```

#### ***int() float() complex()***

```python
>>> int('520')
520

//int()直接舍弃小数部分
>>> int(3.14)
3
>>> int(9.99999)
9
>>> float('3.14')
3.14
>>> float(520)
520.0

//可以使用科学计数法
>>> float('+1E6')
1000000.0
>>> complex("1+2j")
(1+2j)

//字符串之间不能有空格
>>> complex('1 + 2j')
Traceback (most recent call last):
  File "<pyshell#27>", line 1, in <module>
    complex('1 + 2j')
ValueError: complex() arg is a malformed string
```

#### ***pow(x,y)*** 和 x ** y

```python
>>> pow(2,3)
8
>>> 2**3
8
```

```python
//pow(x,y,z)可以传入第三个参数进行取余
>>> pow(2,3,5)
3
>>> 2 ** 3 % 5
3
```

#### ***Fraction() （分数形式）***

```python
from fractions import Fraction
```

Fraction函数支持分数运算，输入参数可以是一对整数，一个分数，一个小小数或者一个字符型数字。

**1.Fraction(分子=0, 分母=1)**

默认参数分子为0，分母为1。
输入两个整数(分别作为分子、分母)，返回两数约分后的结果。

```python
>>> Fraction()
Fraction(0, 1)

>>> Fraction(10,6)
Fraction(5, 3)
>>> Fraction(1,2)
Fraction(1, 2)

```

**2.Fraction(浮点数)**

输入浮点数，会返回该数的分子分母形式。

```python
>>> Fraction(3.5)
Fraction(7, 2)
```

**3.Fraction(分数)**

输入分数，会返回该数的分子分母形式。

```python
>>> Fraction(3/2)
Fraction(3, 2)
```

**4.Fraction(十进制整数)**

输入一个整数，默认输入的是分子，分母为1。

```python
>>> Fraction(4)
Fraction(4, 1)
```

**5.Fraction(字符串)**
输入字符型数字，会返回该数的分子分母形式。

```python
>>> Fraction('4.2')
Fraction(21, 5)
>>> Fraction('5/3')
Fraction(5, 3)
```





## 布尔类型

### ***True和False***

```python
//对于字符串类型 只有空字符串是False 其余均为True 哪怕只有一个空格
>>> bool("假")
True
>>> bool("false")
True
>>> bool(" ")
True
>>> bool("")
False

//对于布尔类型 False为False True为True  true和false不行
>>> bool(true)
Traceback (most recent call last):
  File "<pyshell#38>", line 1, in <module>
    bool(true)
NameError: name 'true' is not defined
>>> bool(True)
True
>>> bool(False)
False

//对于数字类型 只有0才为False 其余均为True
>>> bool(0)
False
>>> bool(0.000000001)
True
>>> bool(0.0)
False
>>> bool(0j)
False

//True==1  False==2 布尔类型其实就是特殊的整数类型
>>> 1 == True
True
>>> 2 == False
False
>>> True + False
1
```

![5](.\图片\5.png)



### 逻辑运算符（Boolean Operation）

![6](.\图片\6.png)

#### 短路逻辑
短路逻辑的核心思想：从左往右，只有当第一个操作数的值无法确定逻辑运算的结果时，才对第二个操作数进行求值

```python

>>> 3 and 4
4
>>> 4 and 5
5
>>> "liushang" and "daling"
'daling'
>>> "liushang" or "daling"
'liushang'

>>> x = (not 1) or (0 and 1) or (3 and 4) or (5 and 6) or (7 and 8 and 9)
>>> x
4
>>> (not 1) or (0 and 1)
0
>>> (not 1) or (0 and 1) or (3 and 4)
4
>>> (not 1) or (0 and 1) or (3 and 4) or (5 and 6)
4
>>> (not 1) or (0 and 1) or (3 and 4) or (5 and 6) or (7 and 8 and 9)
4

>>> 0 and 3
0
>>> 0 or 4
4
```

#### 运算符优先级 Operator precedence

```python
>>> not 1 or 0 and 1 or 3 and 4 or 5 and 6 or 7 and 8 and 9
4
```

![7](.\图片\7.png)



## 流程图（Flowchart）

流程图是一种用于表示算法或者代码流程的框图组合，它以不同类型的框框代表不同种类的程序步骤，每两个步骤之间以箭头连接起来

![8](.\图片\8.png)

## 思维导图（Mind Map）

思维导图又叫心智图，是表达发散性思维的有效的图形思维工具，它简单却极其有效，是一种革命性的思维工具



## 分支循环语句

### 1.if

```python
条件成立时执行的语句 if condition else 条件不成立时执行的语句
```

### 2.while

### 3.for

```python
# for-each
>>> for each in "Liushang":
	print(each)
	
L
i
u
s
h
a
n
g

# range(x)   0~~x-1
>>> for i in range(10):
	print(i)

	
0
1
2
3
4
5
6
7
8
9

# range(x,y)   x~~y-1
>>> for i in range(5,10):
	print (i)

	
5
6
7
8
9

# range(x,y,z)  x~~y-1 每隔z赋值一次
>>> for i in range(5,100,5):
	print(i)

	
5
10
15
20
25
30
35
40
45
50
55
60
65
70
75
80
85
90
95
```



## 列表

```python
>>> rhyme = [1,2,3,4,5,"Liushang"]
>>> for each in rhyme:
	print(each)

1
2
3
4
5
Liushang
>>> rhyme[0]
1
>>> rhyme[1]
2
>>> lenth = len(rhyme)
>>> rhyme[lenth - 1]
'Liushang'
>>> rhyme[-1]
'Liushang'
>>> rhyme[0:3]
[1, 2, 3]
>>> rhyme[3:6]
[4, 5, 'Liushang']
>>> rhyme[:3]
[1, 2, 3]
>>> rhyme[:]
[1, 2, 3, 4, 5, 'Liushang']
>>> rhyme[0:6:2]
[1, 3, 5]
>>> rhyme[::2]
[1, 3, 5]
>>> rhyme[::-2]
['Liushang', 4, 2]
>>> rhyme[::-2]
['Liushang', 4, 2]
>>> rhyme[::-1]
['Liushang', 5, 4, 3, 2, 1]
```

### 1.增删改查

```python
# 增加元素
>>> heros = ["钢铁侠","绿巨人"]

# append()添加一个列表元素
>>> heros.append("黑寡妇")
>>> heros
['钢铁侠', '绿巨人', '黑寡妇']

# extend([])添加多个列表元素
>>> heros.extend(["鹰眼","灭霸","雷神"])
>>> heros
['钢铁侠', '绿巨人', '黑寡妇', '鹰眼', '灭霸', '雷神']



#插入元素
>>> s = [1,3,4,5]

# insert(x,y)将x插入搭y位置
>>> s.insert(1,2)
>>> s
[1, 2, 3, 4, 5]

# 插入到列表头
>>> s.insert(0,0)
>>> s
[0, 1, 2, 3, 4, 5]

# 用insert(len(s),y)实现append方法 插入到列表尾
>>> s.insert(len(s),6)
>>> s
[0, 1, 2, 3, 4, 5, 6]

# 删除 多个值相同元素，只会删除下标最小的一个 删除不存在的元素会抛出异常
>>> heros.remove("灭霸")
>>> heros
['钢铁侠', '绿巨人', '黑寡妇', '鹰眼', '雷神']

# pop()删除指定位置的元素
>>> heros.pop(2)
'黑寡妇'
>>> heros
['钢铁侠', '绿巨人', '鹰眼', '雷神']

# clear()删除全部列表元素
>>> heros.clear()
>>> heros
[]



# 列表是可变的，而字符串是不可变的
#改变列表中元素
>>> heros = ['钢铁侠', '绿巨人', '黑寡妇', '鹰眼', '雷神']
>>> heros
['钢铁侠', '绿巨人', '黑寡妇', '鹰眼', '雷神']
>>> heros[4] = "蜘蛛侠"
>>> heros
['钢铁侠', '绿巨人', '黑寡妇', '鹰眼', '蜘蛛侠']
>>> heros[3:] = ["武松","林冲","李逵"]
>>> heros
['钢铁侠', '绿巨人', '黑寡妇', '武松', '林冲', '李逵']


# 列表排序
>>> nums = [1,2,9,6,4,7,3,4,6,3,5]
>>> nums.sort()
>>> nums
[1, 2, 3, 3, 4, 4, 5, 6, 6, 7, 9]

#倒序排列
>>> nums.reverse()
>>> nums
[9, 7, 6, 6, 5, 4, 4, 3, 3, 2, 1]
>>> heros.reverse()
>>> heros
['李逵', '林冲', '武松', '黑寡妇', '绿巨人', '钢铁侠']
#用sort实现倒序
>>> nums.sort(reverse=True)
>>> nums
[9, 7, 6, 6, 5, 4, 4, 3, 3, 2, 1]


#查询
>>> nums
[9, 7, 6, 6, 5, 4, 4, 3, 3, 2, 1]
>>> nums.count(4)
2
>>> heros.index("绿巨人")
4
>>> heros[heros.index('绿巨人')]='神奇女侠'
>>> heros
['李逵', '林冲', '武松', '黑寡妇', '神奇女侠', '钢铁侠']

#查询列表中有多个相同元素，返回第一个元素的下标
>>> nums = [3,11,9,6,8,3,5,3]
>>> nums.index(3)
0
# 从1开始查找到七
>>> nums.index(3,1,7)
5

#复制列表  浅拷贝
>>> nums_copy1 = nums.copy()
>>> nums_copy1
[3, 11, 9, 6, 8, 3, 5, 3]

>>> nums_copy2 = nums[:]
>>> nums_copy2
[3, 11, 9, 6, 8, 3, 5, 3]

#列表的运算
>>> s = [1,2,3,4]
>>> t = [4,5,6,7]
>>> s+t
[1, 2, 3, 4, 4, 5, 6, 7]
>>> s*3
[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]

# 嵌套列表 二维列表
>>> matrix = [[1,2,3],[4,5,6],[7,8,9]]
>>> print(matrix)
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]

>>> for i in matrix:
	for each in i:
		print(each)

		
1
2
3
4
5
6
7
8
9
>>> for i in matrix:
	for each in i:
		print(each,end=' ')
	print()

	
1 2 3 
4 5 6 
7 8 9 
>>> matrix[0]
[1, 2, 3]
>>> matrix[0][0]
1
>>> matrix[1][1]
5
>>> matrix[2][2]
9

>>> A = [0] * 3
>>> A
[0, 0, 0]

# 用*生成二维数组
>>> for i in range(3):
	A[i] = [0] * 3
	
>>> A
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]

#不能采用以下方式
>>> B = [[0] * 3]
>>> B
[[0, 0, 0]]
>>> B = [[0] * 3] * 3
>>> B
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]

#原因如下
>>> A[1][1] = 1
>>> A
[[0, 0, 0], [0, 1, 0], [0, 0, 0]]
>>> B[1][1] = 1
>>> B
[[0, 1, 0], [0, 1, 0], [0, 1, 0]]
# B实现的只是对同一引用的拷贝  A实现的则是对同一组元素的拷贝

>>> x = "Liushang"
>>> y = "Liushang"
>>> x is y
True
>>> x = [1,2,3]
>>> y = [1,2,3]
>>> x is y
False
>>> A[0] is A[1]
False
>>> A[1] is A[2]
False
>>> B[0] is B[1]
True
>>> B[1] is B[2]
True

# 浅拷贝只是对引用的拷贝 改变一个值，所以的引用都会随着改变
# = 是浅拷贝
# .copy()也是浅拷贝
# 切片也是
>>> x = [1,2,3]
>>> y = x
>>> y
[1, 2, 3]
>>> x[1] = 9
>>> x
[1, 9, 3]
>>> y
[1, 9, 3]

#.copy()
>>> x = [1,2,3]
>>> y = x.copy()
>>> y
[1, 2, 3]
>>> x[1] = 9
>>> y
[1, 2, 3]

# copy()只能拷贝表层对象
>>> x = [[1,2,3],[4,5,6],[7,8,9]]
#列表的copy()方法
>>> y = x.copy()
>>> y
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> x[1][1] = 0
>>> y
[[1, 2, 3], [4, 0, 6], [7, 8, 9]]

# 切片
>>> x = [1,2,3]
>>> y = x[:]
>>> y
[1, 2, 3]
>>> x[1] = 9
>>> y
[1, 2, 3]

# copy模块的浅拷贝
>>> import copy
# copy模块的copy函数
>>> y=copy.copy(x)
>>> x[2][2] = 0
>>> x
[[1, 2, 3], [4, 0, 6], [7, 8, 0]]
>>> y
[[1, 2, 3], [4, 0, 6], [7, 8, 0]]

# 深拷贝 deepcopy()在对原对象拷贝的同时，也对对象中引用的子对象一并进行了拷贝
>>> import copy
>>> y = copy.deepcopy(x)
>>> x[1][1] = 10
>>> x
[[1, 2, 3], [4, 10, 6], [7, 8, 0]]
>>> y
[[1, 2, 3], [4, 0, 6], [7, 8, 0]]
```

### 2.列表推导式

```python
# 若使用已掌握的方法对列表元素进行扩大
>>> x = [1,2,3,4,5]
>>> for i in range(len(x)):
	x[i] = x[i] * 2

	
>>> x
[2, 4, 6, 8, 10]

#使用列表推导式 效率更高 以c语言运行  通过新建一个新列表，再赋值回原来的列表
>>> x = [1,2,3,4,5]
>>> x = [i * 2 for i in x]
>>> x
[2, 4, 6, 8, 10]

>>> x = []
>>> x
[]
>>> x = [i for i in range(10)]
>>> x
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> x = [i+1 for i in range(10)]
>>> x
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 使用循环方式添加方法 通过迭代的方式 将列表中的元素一个个进行替换
>>> x = []
>>> for i in range(10):
	x.append(i+1)
>>> x
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# 对字符串进行使用
>>> y = [c * 2 for c in "Liushang"]
>>> y
['LL', 'ii', 'uu', 'ss', 'hh', 'aa', 'nn', 'gg']

# 查询字符串中字母对应的Unicode编码
>>> code = [ord(c) for c in "Liushang"]
>>> code
[76, 105, 117, 115, 104, 97, 110, 103]

# 输出二维数组第二列元素
>>> matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> col2 = [row[1] for row in matrix]
>>> col2
[2, 5, 8]

# 输出二维数组中对角线元素
>>> d = [matrix[i][i] for i in range(len(matrix))]
>>> d
[1, 5, 9]

# 输出二维数组中斜对角线元素
>>> d = [matrix[i][len(matrix)-1-i] for i in range(len(matrix))]
>>> d
[3, 5, 7]

# 列表推导式生成二维数组
>>> S = [[0] * 3 for i in range(3)]
>>> S
[[0, 0, 0], [0, 0, 0], [0, 0, 0]]
>>> S[1][1] = 9
>>> S
[[0, 0, 0], [0, 9, 0], [0, 0, 0]]

>>> even = [i for i in range(10) if i % 2 == 0]
>>> even
[0, 2, 4, 6, 8]
>>> odd = [i + 1 for i in range(10) if i % 2 == 0]
>>> odd
[1, 3, 5, 7, 9]

#使用列表推导式实现二维数组转化为一位数组
>>> matrix
[[1, 2, 3], [4, 5, 6], [7, 8, 9]]
>>> fltten = [col for row in matrix for col in row]
>>> fltten

#使用循环实现二维数组转化为一维数组
>>> flatten = []
>>> for row in matrix:
	for col in row:
		flatten.append(col)
>>> flatten
[1, 2, 3, 4, 5, 6, 7, 8, 9]

>>> [x + y for x in "lrz" for y in "cyl"]
['lc', 'ly', 'll', 'rc', 'ry', 'rl', 'zc', 'zy', 'zl']

# 如果一个变量是临时的，可以用_表示
>>> _ = []
>>> for x in "lrz":
	for y in "cyl":
		_.append(x + y)
		
>>> _
['lc', 'ly', 'll', 'rc', 'ry', 'rl', 'zc', 'zy', 'zl']
```

## 元组

也是一个序列，既能像列表一样，同时容纳多种类型的对象，也拥有字符串不可变的特性

- 列表 -- [元素1，元素2，元素3，...]
- 元组 -- （元素1，元素2，元素3，...）

```python
>>> rhyme = (1,2,3,4,5,"上山打老虎")
>>> rhyme
(1, 2, 3, 4, 5, '上山打老虎')

# 定义元组可以省略（），但最好都加上
>>> rhymePlus = 1,2,3,4,5,"上山打老虎"
>>> rhymePlus
(1, 2, 3, 4, 5, '上山打老虎')
>>> rhyme[-1]
'上山打老虎'

# 元组中元素不能改变
>>> rhyme[1] = 10
Traceback (most recent call last):
  File "<pyshell#5>", line 1, in <module>
    rhyme[1] = 10
TypeError: 'tuple' object does not support item assignment

# 元组也可以使用切片操作
>>> rhyme[:3]
(1, 2, 3)
>>> rhyme[3:]
(4, 5, '上山打老虎')
>>> rhyme[:]
(1, 2, 3, 4, 5, '上山打老虎')
>>> rhyme[::2]
(1, 3, 5)
>>> rhyme[::-1]
('上山打老虎', 5, 4, 3, 2, 1)

# 元组拥有列表关于查询和基础运算的功能
>>> nums = 3,1,9,6,8,3,5,0
>>> nums.count(3)
2
>>> nums.index(0)
7
>>> num = 4,2,5,7,5,9,4,8,3,7
>>> num + nums
(4, 2, 5, 7, 5, 9, 4, 8, 3, 7, 3, 1, 9, 6, 8, 3, 5, 0)
>>> num,nums
((4, 2, 5, 7, 5, 9, 4, 8, 3, 7), (3, 1, 9, 6, 8, 3, 5, 0))
>>> for each in nums:
	print(each)

	
3
1
9
6
8
3
5
0
>>> w = num,nums
>>> w
((4, 2, 5, 7, 5, 9, 4, 8, 3, 7), (3, 1, 9, 6, 8, 3, 5, 0))
>>> for i in w:
	for each in i:
		print(each)

		
4
2
5
7
5
9
4
8
3
7
3
1
9
6
8
3
5
0

#可以根据一个元组生成列表（列表推导式）
>>> [each * 2 for each in nums]
[6, 2, 18, 12, 16, 6, 10, 0]
#但不可以用一个元组生成一个元组
>>> (each * 2 for each in nums)
<generator object <genexpr> at 0x000001197DD0CF20>

# 生成单元素元组要加,
>>> x = (520)
>>> type(x)
<class 'int'>
>>> x = (520,)
>>> type(x)
<class 'tuple'>

# 不仅元组可以这样单独赋值，列表和字符串也可以，但是左右元素数量必须一样
>>> t = (123,"Liushang",3.14)
>>> x,y,z = t
>>> x
123
>>> y
'Liushang'
>>> z
3.14

>>> t = (123,"Liushang",3.14)
>>> x,y,z = t
>>> x
123
>>> y
'Liushang'
>>> z
3.14
>>> t = [123,'Liushang', 3.14]
>>> a,b,c=t
>>> a
123
>>> b
'Liushang'
>>> c
3.14
>>> q,w,e,r,t,y,u,i=b
>>> q
'L'
>>> w
'i'
>>> e
'u'
>>> r
's'
>>> t
'h'
>>> y
'a'
>>> u
'n'
>>> i
'g'

# 左右元素数量必须一致，除非加*
>>> s,d,f = b
SyntaxError: invalid syntax
>>> s,d,*f = b
>>> s
'L'
>>> d
'i'
>>> f
['u', 's', 'h', 'a', 'n', 'g']


#py中之所以可以这样写，是因为他利用了一个元组进行赋值
>>> x,y = 10,20
>>> x
10
>>> y
20

>>> _ = 10,20
>>> x,y = _
>>> x
10
>>> y
20


# 单纯元组的元素不能被修改，但是如果元组的元素是在一个可变的列表中，元组的元素就能够被修改
>>> s = [1,2,3]
>>> t = [4,5,6]
>>> w = (s,t)
>>> w
([1, 2, 3], [4, 5, 6])
>>> w[0][0] = 0
>>> w
([0, 2, 3], [4, 5, 6])
```



## 字符串

### 1.大小写字母换来换去

- capitalize()

```python
# 将字符春的首字母变成大写，其余部分变成小写
# 不是改变原来的字符串，而是生成一个新的字符串，因为字符串是一个不可变的类型
>>> x = "I Love CYL"
>>> x.capitalize()
'I love cyl'
>>> x
'I Love CYL'
```



- casefold()

```python
# 将所有的字母变成小写  能支持                                                                                          
>>> x = "I Love CYL"
>>> x.casefold()
'i love cyl'
```



- title()

```python
# 将字符串所有的首字母大写，其余小写
>>> x.title()
'I Love Cyl'
```



- swapcase()

```python
# 将字符串中所有字母的大小写进行转换
>>> x.swapcase()
'i lOVE cyl'
```



- upper()

```python
#将字符串中所有字母变成大写
>>> x.upper()
'I LOVE CYL'
```



- lower()

```python
#将字符串中所有字符变成小写 只能支持英语
>>> x.lower()
'i love cyl'
```

### 2.左中右对齐

```python
#本质是创建一个width大小的“   ”
#fillchar代表填充的字符
>>> x="有内鬼，停止交易"

#中间对齐
1. center(width,fillchar='')
>>> x.center(5)
'有内鬼，停止交易'

>>> x.center(15)
'    有内鬼，停止交易   '

#左对齐
2.ljust(width,fillchar='')
>>> x.ljust(15)
'有内鬼，停止交易       '

#右对齐
3.rjust(width,fillchar='')
>>> x.rjust(15)
'       有内鬼，停止交易'

#左边填充0
4.zfill(width)
>>> x.zfill(15)
'0000000有内鬼，停止交易'
```

### 3.查找

```python
#统计字符串中某字符出现的个数，并可指定开始和结束的位置
1.count(sub[,start[,end]])
>>> x = "上海自来水来自海上"
>>> x.count("海")
2
>>> x.count("海", 0, 5)
1

#从左向右查找字符串中该字符第一次出现的位置
2.find(sub[,start[,end]])
>>> x.find("海")
1
#查找不到会显示-1
>>> x.find("李")
-1


#从右向左查找字符串中该字符第一次出现的位置
3.rfind(sub[,start[,end]])
>>> x.rfind("海")
7

#与find功能基本相同
4.index(sub[,start[,end]])
>>> x.index("海")
1

#查询不到会抛出异常
>>> x.index("李")
Traceback (most recent call last):
  File "<pyshell#103>", line 1, in <module>
    x.index("李")
ValueError: substring not found

#与rfind功能基本相同
5.rindex(sub[,start[,end]])
>>> x.rindex("海")
7

```

### 4.替换

```python
#将字符串中的tab全部替换成空格 参数是指定一个tab等于几个空格
1.expandtabs([tabsize=4])
>>> code = """
	print("I Love Cyl")
    print("Cyl Love me")"""
>>> new_code = code.expandtabs(4)
>>> print(new_code)

    print("I Love Cyl")
    print("Cyl Love me")

#返回一个将所有old参数指定的子字符串替换为new参数指定的新字符串，count参数指定的是替换的次数,默认值是-1
2.replace(old,new,count=-1)
>>> "在吗？？我在宿舍楼下，快点下来憨宝子！".replace("在吗","想你")
'想你？？我在宿舍楼下，快点下来憨宝子！'

#返回一个根据table参数转换后的新字符串,参数的名字是table，指定转换规则的表格
#str.maketrans(x,[,y[,z]])获取table这个表格 将规则赋值给这个表格
3.translate(table)
>>> table = str.maketrans("ABCDEFG","1234567")
>>> "I LOVE CYL VERY MUCH".translate(table)
'I LOV5 3YL V5RY MU3H'
>>> "I LOVE CYL VERY MUCH".translate(str.maketrans("CYL","LRZ"))
'I ZOVE LRZ VERR MULH'

#str.maketrans(x,y,z) z代表将指定的字符串忽略
>>> "I Love Cyl".translate(str.maketrans("Cyl","Lrz","Love"))
'I  Lrz'
```

### 5.判断

```python
#判断这个参数指定的子字符串是否出现在字符串的开始位置
1.startswith(prefix[,start[,end]])
>>> x.startswith("我")
True

#判断这个参数指定的子字符串是否出现在字符串的结束位置
#可以多加两个参数指定起止位置 从下标为start的位置开始，到下标为end前一个位置结束！！！！！前一个
2.endwith(prefix[,start[,end]])
>>> x.endswith("子")
True
>>> x.endswith("宝子")
True
>>> x.endswith("宝子",0,4)
False
>>> x.endswith("憨宝",0,4)
False
>>> x.endswith("憨",0,4)
True
>>> x[4]
'宝'
>>> x[0:4]
'我爱陈憨'
>>> x[1:4]
'爱陈憨'

>>> x = "我爱她"
>>> if x.startswith(("我","你")):
	print("大家都爱宝子")

大家都爱宝子
>>> x="I love python"

#.istitle()检查所有单词首字母是否是大写
>>> x.istitle()
False

#检查所有字母是否都为大写
>>> x.isupper()
False

>>> x.upper().isupper()
True

#检测字符串中是否都为字母 空格不是字母
>>> x.isalpha()
False

#检测是否都为空格
>>> "\n           ".isspace()
True

#检验是否都为可打印字符  反义字符不可以被打印
>>> x = "I love python"
>>> x.isprintable()
True
>>> "I love python\n".isprintable()
False

#判断数字  isdecimal() isdigit()  isnumeric()
>>> x = "12345"
>>> x.isdecimal()
True
>>> x.isdigit()
True
>>> x.isnumeric()
True

>>> x = "2²"
>>> x.isdecimal()
False
>>> x.isdigit()
True
>>> x.isnumeric()
True

>>> x = "ⅠⅡⅢⅣⅤ"
>>> x.isdecimal()
False
>>> x.isdigit()
False
>>> x.isnumeric()
True

>>> x = "一二三四五"
>>> x.isdecimal()
False
>>> x.isdigit()
False
>>> x.isnumeric()
True

# isalnum() 表示只要是个是数字和字母就返回True
#isidentifier() 表示该字符串是否是一个合法的Python标识符


#判断一个字符串是否是关键字
>>> import keyword
>>> keyword.iskeyword("if")
True
>>> keyword.iskeyword("py")
False

#截取字符串
# 去除两侧空白
1. strip(chars = None)
>>> "     左右不要留白      ".strip()
'左右不要留白'

# 去除左侧空白
2. lstrip(chars = None)
>>> "     左侧不要留白".lstrip()
'左侧不要留白'

#去除右侧空白
3. rstrip(chars = None)
>>> "右侧不要留白       ".rstrip()
'右侧不要留白'

# 虽然传入的是多个字符，但是按照顺序一个一个进行
>>> "www.liushang.com".strip(".")
'www.liushang.com'
>>> "www.liushang.com".lstrip("www.")
'liushang.com'
>>> "www.liushang.com".lstrip("w")
'.liushang.com'
>>> "www.liushang.com".lstrip("w.")
'liushang.com'
>>> "www.liushang.com".lstrip("wcom.")
'liushang.com'
>>> "www.liushang.com".rstrip("wcom.")
'www.liushang'
>>> "www.liushang.com".strip("wcom.")
'liushang'

# 指定要删除的前缀或者后缀
4. removeprefix(prefix)
>>> "www.liushng.com".removeprefix("www.")
'liushng.com'

5. removesuffix(suffix)
>>> "www.liushng.com".removesuffix(".com")
'www.liushng'

```

### 6.拆分和拼接

```python
# partition()  rpartiton()从左向右或者艹右向左按照规定的分隔符进行分割
>>> "www.liushng.com".partition(".")
('www', '.', 'liushng.com')
>>> "www.liushng.com".rpartition(".")
('www.liushng', '.', 'com')

#split(sep=None,maxsplit=-1) 默认情况下，是切分空格的
>>> "苟日新，日日新，又日新".split()
['苟日新，日日新，又日新']
>>> "苟日新 日日新 又日新".split()
['苟日新', '日日新', '又日新']

#可以规定进行切割的符号
>>> "苟日新，日日新，又日新".split("，")
['苟日新', '日日新', '又日新']

#默认情况下，rsplit()和split()结果相同
>>> "苟日新，日日新，又日新".rsplit("，")
['苟日新', '日日新', '又日新']

# 后面参数表示切割几次，默认情况下全切割
>>> "苟日新，日日新，又日新".rsplit("，",1)
['苟日新，日日新', '又日新']

# splitline() 自动根据行进行分割  （）中加上True输出结果包括换行符
>>> "苟日新\n日日新\n又日新".splitlines()
['苟日新', '日日新', '又日新']
>>> "苟日新\r日日新\r又日新".splitlines()
['苟日新', '日日新', '又日新']
>>> "苟日新\r\n日日新\r\n又日新".splitlines()
['苟日新', '日日新', '又日新']
>>> "苟日新\r\n日日新\r\n又日新".splitlines(True)
['苟日新\r\n', '日日新\r\n', '又日新']

# "".join([])方法进行字符串 拼接
>>> ".".join(["www","liushang","com"])
'www.liushang.com'
>>> "~".join(["liu","shang"])
'liu~shang'

# join的效率和速度比+快很多
>>> s = "Liushang"
>>> s += s
>>> s
'LiushangLiushang'
>>> s = "Liushang"
>>> "".join(["Liushang","Liushang"])
'LiushangLiushang'
```



### 7.格式化

```python
# "{}".format() 使用一对{}在源字符串中进行替换（占一个坑位），真正的内容放在format()里面的参数内
#format()括号中的内容被当成元组来对待，所以可以指定{}中的内容
>>> "{}看到{}就很激动".format("Lrz","Cyl")
'Lrz看到Cyl就很激动'
>>> "{1}看到{0}就很激动".format("Lrz","Cyl")
'Cyl看到Lrz就很激动'

#像是vue一样可以传递参数
>>> "我叫{name},我爱{fav}".format(name = "Lrz",fav = "Cyl")
'我叫Lrz,我爱Cyl'

#输出一对{}
>>> "{},{},{}".format(1,{},2)
'1,{},2'
>>> "{},{{}},{}".format(1,2)
'1,{},2'

#alien排列位置  :^代表居中 10代表字符串大小 :>代表向右排列 :<代表向左排列
>>> "{:^10}".format(200)
'   200    '
>>> "{:>10},{:<10}".format(200,500)
'       200,500       '

#用0填充 只能填充数字
>>> "{:010}".format(520)
'0000000520'
>>> "{:010}".format(-520)
'-000000520'
>>> "{:010}".format("liushang")
Traceback (most recent call last):
  File "<pyshell#44>", line 1, in <module>
    "{:010}".format("liushang")
ValueError: '=' alignment not allowed in string format specifier

>>> "{1:%>10},{0:%<10}".format(520,401)
'%%%%%%%401,520%%%%%%%'


#仅对数字类型有效
# “+” 正数在前面添加正号（+），复数在前面添加负号（-）
# “-”只有复数在前面添加负号（-），默认行为
#空格 正数在前面添加一个空格，复数在前面添加负号（-）
# “，” 使用，作为千分符（每隔三位加一个，）
# “_” 使用，作为千分符（每隔三位加一个_）
>>> "{:+},{:+}".format(250,-250)
'+250,-250'
>>> "{:-},{:-}".format(250,-250)
'250,-250'

>>> "{:,}".format(1234)
'1,234'
>>> "{:_}".format(1234)
'1_234'

# 对于[type]设置为'f'或者'F'的浮点数来说，是限定小数点后显示多少个数位
# 对于[type]设置为'g'或者'G'的浮点数来说，是限定小数点前后一共显示多少个数位
# 对于非数字类型来说，限定的是最大字段的大小
# 对于整数类型来说，则不允许使用[.percision]选项
>>> "{:2f}".format(3.1415926)
'3.141593'
>>> "{:.2f}".format(3.1415926)
'3.14'

>>> "{:.2g}".format(3.1415926)
'3.1'
>>> "{:2g}".format(3.1415926)
'3.14159'

>>> "{:.2}".format("I Love Hamburger")
'I '
>>> "{:.6}".format("I Love Hamburger")
'I Love'

>>> "{:.6}".format(100000000000)
Traceback (most recent call last):
  File "<pyshell#57>", line 1, in <module>
    "{:.6}".format(100000000000)
ValueError: Precision not allowed in integer format specifier
>>> "{:.6g}".format(100000000000)
'1e+11'
>>> "{:.6f}".format(100000000000)
'100000000000.000000'


# type
# 'b' 将参数以二进制形式输出
# 'c' 将参数以Unicode字符的形式输出
# 'd' 将参数以十进制的形式输出
# 'o' 将参数以八进制的形式输出
# 'x' 将参数以十六进制的形式输出
# 'n' 与d类似，不同之处在于它会根据当前语言环境设置的分隔符插入到恰当的位置
# None 跟'd'一样
>>> "{:b}".format(80)
'1010000'
>>> "{:c}".format(80)
'P'
>>> "{:d}".format(80)
'80'
>>> "{:o}".format(80)
'120'
>>> "{:x}".format(80)
'50'
>>> "{:n}".format(80)
'80'

>>> "{:#b}".format(80)
'0b1010000'
>>> "{:#d}".format(80)
'80'
>>> "{:#o}".format(80)
'0o120'
>>> "{:#x}".format(80)
'0x50'
>>> "{:#n}".format(80)
'80'

# 'e'将参数以科学计数法的形式输出（用e来表示指数，默认精度是6）
# 'E'将参数以科学计数法的形式输出（用E来表示指数，默认精度是6）
# 'f'将参数以定点表示法的形式输出（'不是数'用'nan'表示，无穷用'inf',默认精度为6）
# 'g' 通用格式，小数以'f'格式输出，大数以'e'的格式输出
# 'G' 通用格式，小数以'F'格式输出，大数以'E'的格式输出
# '%' 百分数形式，默认精度为6
>>> "{:g}".format(1234.56789)
'1234.57'
>>> "{:g}".format(123456789)
'1.23457e+08'

>>> "{:G}".format(1234.56789)
'1234.57'
>>> "{:G}".format(123456789)
'1.23457E+08'

>>> "{:%}".format(0.98)
'98.000000%'
>>> "{:.2%}".format(0.98)
'98.00%'
>>> "{:.{prec}%}".format(3.14159,prec=2)
'314.16%'
```

### 8.f-字符串

> 语法糖：是指计算机语言中添加的某些语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性

```python
#在字符串前面加上'f'或者'F'就可以简单的使用format的类似方法
>>> year=2022
>>> "憨宝子跟玲宝子{}年在一起".format(year)
'憨宝子跟玲宝子2022年在一起'
>>> f"憨宝子跟玲宝子{year}年在一起"
'憨宝子跟玲宝子2022年在一起'
>>> f"1+2={1+2},2的平方是{2*2},3的立方是{3*3*3}"
'1+2=3,2的平方是4,3的立方是27'
```



## 序列

### 列表、元组、字符串的共同点

- 都可以通过索引获取每一个元素
- 第一个元素的索引值都是0
- 都可以通过切片的方法获取一个范围
- 都有很多共同的运算符

**列表、元组、字符串都被统称为序列**

根据是否能被修改这一特征，可以将序列分成可变序列和不可变序列

比如说：列表就是一个典型的可变序列

而元组和字符串则是不可变序列

### 序列的运算符

- **\+ 和 \***

  \+  进行序列拼接

  \* 进行序列重复拷贝

  ```python
  # 
  >>> s= [1,2,3]
  >>> id(s)
  1544394411584
  >>> s *= 2
  >>> id(s)
  1544394411584
  >>> s
  [1, 2, 3, 1, 2, 3]
  
  
  >>> t = (1,2,3)
  >>> id(t)
  1544394669440
  >>> t *= 2
  >>> t
  (1, 2, 3, 1, 2, 3)
  >>> id(t)
  1544393944032
  ```

  

- **is 和 is not**

  - ```python
    # 若两个变量指向同一对象，则返回True，否则为False
    >>> x = "Liushang"
    >>> y = "Liushang"
    >>> x is y
    True
    # 两个列表虽然值相同，但是指向的不是同一个对象
    >>> x = [1,2,3]
    >>> y = [1,2,3]
    >>> x is y
    False
    ```

- **in 和 not in**

```python
>>> "Lrz" in "Lrz love Cyl"
True
>>> "Cyl" in "Lrz love Cyl"
True
```

- **del**

```python
>>> x
[1, 2, 3]
>>> y = "Liushang"
>>> del x,y
>>> x
Traceback (most recent call last):
  File "<pyshell#110>", line 1, in <module>
    x
NameError: name 'x' is not defined
>>> y
Traceback (most recent call last):
  File "<pyshell#111>", line 1, in <module>
    y
NameError: name 'y' is not defined
>>> 


>>> x = [1,2,3,4,5]
>>> del x[1:4]
>>> x
[1, 5]

>>> x = [1,2,3,4,5,6,7,8,9,0]
>>> del x[::2]
>>> x
[2, 4, 6, 8, 0]

>>> x
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]
>>> x.clear()
>>> x
[]
>>> x = [1,2,3,4,5,6,7,8,9,0]
>>> del x[:]
>>> x
[]
```

### 序列的函数

- 列表、元组和字符串相互转换

```python
# list()   将可迭代对象转换成列表
# tuple()  将可迭代对象变成元组
# str()		将可迭代对象转换成字符串
>>> list("Liushang")
['L', 'i', 'u', 's', 'h', 'a', 'n', 'g']
>>> list((1,2,3,4,5))
[1, 2, 3, 4, 5]
>>> tuple("Liushang")
('L', 'i', 'u', 's', 'h', 'a', 'n', 'g')
>>> tuple((1,2,3,4,5))
(1, 2, 3, 4, 5)
>>> tuple([1,2,3,4,5])
(1, 2, 3, 4, 5)
>>> str([1,2,3,4,5])
'[1, 2, 3, 4, 5]'
>>> str((1,2,3,4,5))
'(1, 2, 3, 4, 5)'
```



















## python3常用函数

### zip()函数  打包元组形成新字典

**zip()** 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象，这样做的好处是节约了不少的内存。

我们可以使用 list() 转换来输出列表。

如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 ***** 号操作符，可以将元组解压为列表。

#### 语法

```python
zip([iterable, ...])
#iterabl -- 一个或多个迭代器;
```

#### 返回值

````python
返回一个对象
````

#### 实例

```python
>>> a = [1,2,3]
>>> b = [4,5,6]
>>> c = [4,5,6,7,8]
>>> zipped = zip(a,b)     # 返回一个对象
>>> zipped
<zip object at 0x103abc288>
>>> list(zipped)  # list() 转换为列表
[(1, 4), (2, 5), (3, 6)]
>>> list(zip(a,c))              # 元素个数与最短的列表一致
[(1, 4), (2, 5), (3, 6)]

>>> a1, a2 = zip(*zip(a,b))          # 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式
>>> list(a1)
[1, 2, 3]
>>> list(a2)
[4, 5, 6]
>>>
```

#### 应用--两个列表合并成一个字典

两个列表合并成一个字典，一个列表里的值为key一个列表里的为*Value*

```python
a=[1,2,3,4,5]
b=[6,7,8,9,10]
 
c = dict(zip(a,b))
 
>>> a=[1,2,3,4,5]
>>> b=[6,7,8,9,10]
>>> c=dict(zip(a,b))
>>> c
{1: 6, 2: 7, 3: 8, 4: 9, 5: 10}

>>> a = [1,2,3]
>>> b=[6,7,8,9,10]
>>> c=dict(zip(a,b))
>>> c
{1: 6, 2: 7, 3: 8}
```

zip函数接受任意多个（包括0个和1个）序列作为参数，返回一个tuple列表

然后再用dict转成字典

结果就是



#### 应用--打乱数据集

```python
import random
X = [1, 2, 3, 4, 5, 6]
y = [0, 1, 0, 0, 1, 1]
zipped_data = list(zip(X, y))  
# 将样本和标签一 一对应组合起来,并转换成list类型方便后续打乱操作random.shuffle(zipped_data)  
# 使用random模块中的shuffle函数打乱列表，原地操作，没有返回值
new_zipped_data = list(map(list, zip(*zipped_data)))  
# zip(*)反向解压，map()逐项转换类型，list()做最后转换
new_X, new_y = new_zipped_data[0], new_zipped_data[1]  
# 返回打乱后的新数据
print('X:',X,'\n','y:',y)
print('new_X:',new_X, '\n', 'new_y:',new_y)
```

输出结果(因未设置随机种子seed，因此每次运行结果可能不一样):

```python
X: [1, 2, 3, 4, 5, 6] 
 y: [0, 1, 0, 0, 1, 1]
new_X: [1, 2, 3, 4, 5, 6] 
 new_y: [0, 1, 0, 0, 1, 1]
```



非常感谢你让我了解到zip在处理数据方面的作用。

但美中不足的是你的代码不能实现数据的打乱。

将样本和标签一一对应组合起来，并转换成 list 类型方便后续打乱操作 **random.shuffle(zipped_data)** 。

原因：在上面的这行代码中，你将打乱操作放到注释里了。

重新整理如下：

```python
import random
X = [1, 2, 3, 4, 5, 6]
y = [0, 1, 0, 0, 1, 1]
zipped_data = list(zip(X, y))  
# 将样本和标签一 一对应组合起来,并转换成list类型方便后续打乱操作

random.shuffle(zipped_data)  
# 使用random模块中的shuffle函数打乱列表，原地操作，没有返回值

new_zipped_data = list(map(list, zip(*zipped_data)))  
# zip(*)反向解压，map()逐项转换类型，list()做最后转换

new_X, new_y = new_zipped_data[0], new_zipped_data[1]  
# 返回打乱后的新数据

print('X:',X,'\n','y:',y)
print('new_X:',new_X, '\n', 'new_y:',new_y)
```

我还有一个问题，如果真正的在机器学习模型训练中，将样本和标签一 一对应组合起来，是使用一下代码吗？

```python
X = [1, 2, 3, 4, 5, 6]
y = [0, 1, 0, 0, 1, 1]

zipped_data = list(zip(X, y)) 
```

但是在上述代码中，写x序列比较麻烦，可以采用以下代码:

```python
lst = []
for i in range(1，n+1): # n为数据集的个数
    lst.append(i)

# -----------------------

enumerate(x, start = 1) # x 为数据集
```



**enumerate()** 函数返回的是一个索引序列（对象），所以你第三段代码末尾 `enumerate(x, start = 1)` 只实现了 `zip(x, y)`， 若想实现 `zipped_data = list(zip(x, y))` 你需要将这句修改为 `zipped_data = list(enumerate(x, start = 1)`。




### map()实现输入多个数字
用map( ) ， [split](https://so.csdn.net/so/search?q=split&spm=1001.2101.3001.7020)( )以及input( ) 可以实现用input( )同时输入多个数。

#### 1.map( )

map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。

#### 2.split( )

拆分[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020)。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）

#### 3.map(function,input(“以空格分开”).split())

由于input( )输出的是用空格分开的字符串，split( )会分割开各个值并放到列表中，此时在列表中的值是字符串，如果要用于运算必须在map( )中利用int( )或者float( )等处理，再赋值。如果需要赋值的值都是字符串的话就没必要用map函数了。

#### 示例代码如下

```python
# 适用于已知输入的数字个数
a,b =input('输入a,b空格隔开:').split()
#此时a,b为str型
a,b =map(int,input('输入a,b空格隔开:').split())
#此时a,b为int型

a,b=map(int,input().split())
print(a,b)
print(type(a))
 
#运行结果
1 2
1 2
<class 'int'>

#例如：
#日期 00010 00000 00010 00000 00001 00011，翻译为2020年1月3日。
#int(x,2)：将一个二进制的数字准换为十进制。
print("请输入报道日期，每位二进制数之间用空格隔开")
sstr=""
year1,year2,year3,year4,month,day=map(str,input().split())
sstr=sstr+str(int(year1,2))+str(int(year2,2))+str(int(year3,2))+str(int(year4,2))+"年"
sstr=sstr+str(int(month,2))+"月"
sstr=sstr+str(int(day,2))+"日"
print(sstr)
 
#运行结果
请输入报道日期，每位二进制数之间用空格隔开
00010 00000 00001 00100 00100 00001
2014年4月1日
```



### math标准库函数----python

#### 如何加载math库
import math

#### 如何使用math库中的函数

- 在函数名前加math.(函数)

- 如果在加载函数时代码为import math as m则可以用m.(函数)来调用函数

#### 常数
- pi

```python
>>> math.pi
>>> 3.141592653589793
```

- e

```python
>>> math.e
>>> 2.718281828459045
```

#### 一般函数

- ceil(x):功能:返回一个浮点数据,该数据向上取整.

```python
>>> math.ceil(5.21)
>>> 6.0
```

- copysign(x, y):功能:返回入参x,x的符号属性和入参y一致.

>>>math.copysign(4,-1)
>>>-4.0

- fabs(x):功能:返回入参x的绝对值.

>>>math.fabs(-2)
>>>2.0

- factorial(x):功能:返回x的阶乘.

>>>math.factorial(5)
>>>120

- floor(x):功能:返回一个浮点数据,该数据向下取整.

>>>math.floor(6.12)
>>>6.0

- fmod(x, y):功能:取模运算,等同x%y,注意表达式的符号看参数x.

>>>math.fmod(3,2)
>>>1.0

- frexp(x):功能:效果等同公式x=m*2**e 返回二元数组(m,e).

>>>math.frexp(8)
>>>(0.5,4)

- fsum(iterable):功能:计算列表内部所有数据元素之和.返回浮点类型.

>>>f = [1,2.0,3.1]
>>>math.fsum(f)
>>>6.1

- isinf(x):功能:判断浮点类型的入参是否为正向无穷大还是负向无穷大.

>>>math.isinf(6.66)
>>>False

- isnan(x):功能:判断浮点类型的入参是否为数据.

>>>math.isnan(6.66)
>>>False

- ldexp(x, i):功能:和函数frexp(x)函数相反等同公式:x*2**i

>>>math.ldexp(0.5,4)
>>>8.0

- modf(x):功能:返回入参x的整数和小数部分.

>>>math.modf(8)
>>>(0.0,8.0)

- trunc(x):功能:截取浮点数据的小数部分.

>>>math.trunc(6.66)
>>>6

- exp(x):功能:指数运算,等同公式e**x.

>>>math.exp(5)
>>>148.4131591025766

>>>math.exp(1e-5)-1
>>>1.0000050000069649e-05

- expm1(x):功能:与exp(x)不同在于该函数会有减1操作,小数部分的精度也有区别.

>>>math.expm1(5)
>>>147.4131591025766

>>>math.expm1(1e-5)
>>>1.0000050000069649e-05

- log(x[, base]):功能:取log运算.如果入参只有1个,那么base=e.

>>>math.log(4)
>>>1.3862943611198906

>>>math.log(4,2)
>>>2.0

- log1p(x):功能:取log运算,等同于1+x (base e).

>>>math.log1p(4)
>>>1.6094379124341003

- log10(x):功能:取log运算,base=10.

>>>math.log10(100)
>>>2.0

- pow(x, y):功能:幂运算,等同公式x**y.

>>>math.pow(3,2)
>>>9.0

- sqrt(x):功能:开方运算.

>>>math.sqrt(4)
>>>2.0

#### 三角函数
- acos(x):反余弦函数.y = arccos(x),x=[-1,1];

- asin(x):反正弦函数.y=arcsin(x),x=[-1,1];

- atan(x):反正切函数.

- atan2(y, x):返回y/x的反正切函数.

- cos(x):余弦函数.

- sin(x):正弦函数.

- tan(x):正切函数.

- hypot(x, y):返回欧氏范数,等同公式sqrt(xx + yy).









## python3常用库

### Pandas简介

pandas 是 Python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。

pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为最强大、最灵活、可以支持任何语言的开源数据分析工具。经过多年不懈的努力，pandas 离这个目标已经越来越近了。

对于使用 Python 进行数据分析来说，pandas 几乎是无人不知，无人不晓的。今天，我们就来认识认识数据分析界鼎鼎大名的 pandas。

![img](.\csdmtomd\图片\14)



pandas 是第三方库，需要单独安装才能使用。

![img](.\csdmtomd\图片\15)

一般情况下，我们会像下面这样引入 pandas 模块：

![img](.\csdmtomd\图片\16)


将 pandas 简写成 pd 几乎成了一种不成文的规定。因此，只要你看到 pd 就应该联想到这是 pandas。

接下来，我们来认识一下 pandas 中的两个主要数据结构。

#### 主要数据结构

要使用 pandas，你首先得熟悉它的两个主要数据结构：**Series**（一维数据）与**DataFrame**（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。首先，我们来看看什么是 Series。

##### Series

Series 是一种类似于 Numpy 中一维数组的对象，它由一组任意类型的数据以及一组与之相关的数据标签（即索引）组成。举个最简单的例子：

![img](.\csdmtomd\图片\17)

上面的代码将打印出如下内容：

![img](.\csdmtomd\图片\18)


左边的是数据的标签，默认从 0 开始依次递增。右边是对应的数据，最后一行表明了数据类型。

我们也可以像下面这样使用 index 参数自定义数据标签：

![img](.\csdmtomd\图片\19)

运行结果如下：

```python
>>> import pandas as pd
>>> print(pd.Series([2,4,6,8],index = ['a','b','c','d']))
a    2
b    4
c    6
d    8
dtype: int64

```

![img](.\csdmtomd\图片\20)

我们还可以直接使用字典同时创建带有自定义数据标签的数据，pandas 会自动把字典的键作为数据标签，字典的值作为相对应的数据。

![img](.\csdmtomd\图片\22)

运行结果和上面一样：

```python
>>> print(pd.Series({'a':2,'b':4,'c':6,'d':8}))
a    2
b    4
c    6
d    8
dtype: int64
```

![img](.\csdmtomd\图片\21)

访问 Series 里的数据的方式，和 Python 里访问列表和字典元素的方式类似，也是使用中括号加数据标签的方式来获取里面的数据。

![img](.\csdmtomd\图片\23)

```python
>>> s1 = pd.Series([2,4,6,8])
>>> s2 = pd.Series({'a':2,'b':4,'c':6,'d':8})
>>> print(s1[0])
2
>>> print(s2['b'])
4
```




有了带标签的数据有什么用呢？为什么不直接使用 Python 自带的列表或字典呢？

是因为 pandas 有着强大的**数据对齐**功能，什么意思呢？我给你举个例子你就明白了。

假设你开了个小卖部，每天统计了一些零食的销量，你想看一下前两天的总销量如何。使用 pandas 的话，你可以这样写：

```python
>>> s3 = pd.Series({'辣条':14,'面包':7,'可乐':8,'烤肠':10})
>>> s4 = pd.Series({'辣条':20,'面包':3,'可乐':13,'烤肠':6})
>>> s3+s4
辣条    34
面包    10
可乐    21
烤肠    16
dtype: int64
```

![img](.\csdmtomd\图片\24)

上面直接将两个 Series 相加的结果如下：

![img](.\csdmtomd\图片\25)


神奇的事发生了，pandas 自动帮我们将相同数据标签的数据进行了计算，这就是数据对齐。

而如果不用 Series，只用列表或字典，我们还要使用循环来进行计算。而用了 pandas 的 Series，只需要简单的相加即可。

![img](.\csdmtomd\图片\26)

你可能会有疑问，如果两天卖出的零食不一样怎么办，pandas 还能进行数据对齐吗？我们试一下就知道了。

```python
>>> s4 = pd.Series({'辣条':20,'面包':3,'雪碧':13,'泡面':6})
>>> s3+s4
可乐     NaN
泡面     NaN
烤肠     NaN
辣条    34.0
雪碧     NaN
面包    10.0
dtype: float64
```

![img](.\csdmtomd\图片\27)

上面的数据中，只有辣条和面包这两个数据标签是相同的，剩下的数据标签各不相同。上述代码的运行结果如下：

![img](.\csdmtomd\图片\28)

可以看到，对于数据标签不相同的数据，运算后结果是**NaN**。NaN 是 Not a Number（不是一个数字）的缩写，因为其中一个 Series 中没有对应数据标签的数据，无法进行计算，因此返回了 NaN。

![img](.\csdmtomd\图片\29)


对于这种情况，我们想让没有的数据默认为 0，然后再进行计算。这种需求 pandas 可以实现吗？

当然可以！只需调用 Series 的 add() 方法，并设置好默认值即可。具体用法如下：

![img](.\csdmtomd\图片\30)

这样我们就能得到期望的正确结果：

```python
>>> print(s3.add(s4,fill_value=0))
可乐     8.0
泡面     6.0
烤肠    10.0
辣条    34.0
雪碧    13.0
面包    10.0
dtype: float64
```

![img](.\csdmtomd\图片\31)

add()方法对应的是加法，数学中的四则运算在 pandas 中都有一一对应的方法，它们的用法都是类似的。具体对应关系如下图所示：

![img](.\csdmtomd\图片\32)

##### **DataFrame**

Series 是一维数据，而 DataFrame 是二维数据。什么意思呢？你可以把 DataFrame 想象成一个表格，表格有行和列这两个维度，所以是二维数据。

实际上，表格中的每一行或每一列都是一个 Series，这些 Series 就组成了 DataFrame。按行分，每一行数据加上上面的数据标签就是一个 Series。

![img](.\csdmtomd\图片\33)

或者按列分，每一列数据加上左边的数据标签也是一个 Series。

![img](.\csdmtomd\图片\34)

那么，如何用 DataFrame 实现上图中那样的表格呢？也很简单，请看代码：

![img](C:\Users\Dell\Desktop\MarkDown学习\编译原理\图片\28)

上面代码的运行结果如下：

```python
# pandas输出完整、对齐的表格的方法
>>> pd.set_option('display.unicode.ambiguous_as_wide', True)
>>> pd.set_option('display.unicode.east_asian_width', True)

>>> df = pd.DataFrame({'辣条':[14,20],'面包':[7,3],'可乐':[8,13],'烤肠':[10,6]})
>>> df
   辣条  面包  可乐  烤肠
0    14     7     8    10
1    20     3    13     6
>>> 
```

![img](.\图片\9.png)

因为我们的表格中有中文，中文占用的字符和英文、数字占用的字符不一样，因此需要调用pd.set_option()使表格对齐显示。如果你是使用 Jupyter 来运行代码的，Jupyter 会自动渲染出一个表格，则无需这个设置。

上面两条设置是为了让表格更清晰地展示，接下来是本节的重点——**DataFrame**。构建 DataFrame 的办法有很多，**最常用的一种是传入一个由等长列表组成的字典**。即字典里每个值都是列表，且它们的长度必需相等。

这样我们就得到了一个表格，字典的键会作为表格的列名。最左边的是索引，也是默认从 0 开始依次增加。当然，我们也可以在构建 DataFrame 的时候传入 index 参数来自定义索引。

```python
>>> import pandas as pd
>>> data = {'辣条':[14,20],'面包':[7,3],'可乐':[8,13],'烤肠':[10,6]}
>>> df = pd.DataFrame(data,index=['2020-01-01','2020-01-02'])
>>> df
            辣条  面包  可乐  烤肠
2020-01-01  14   7   8  10
2020-01-02  20   3  13   6
```

![img](.\图片\10.png)

全都写在一行代码就太长了，所以我把表格数据放到了变量 data 中。并且通过 index 参数将日期作为了 DataFrame 的索引。运行结果如下：

![img](.\图片\11)


有了 DataFrame 构建的表格，接下来我们来看看如何处理表格中的数据，先从列的查改增删开始。

**列的查改增删**

为了减少重复代码的出现，接下来的讲解都基于下面的代码。

![img](.\图片\12.png)

如果我们只想查看有关可乐的销量数据，我们可以这样写：

![img](.\图片\13.png)


写法和字典取值类似，用中括号加列名的方式获取对应列的数据。运行结果是表格中可乐一列的数据，它是一个 Series，结果如下所示：

```python
>>> df['可乐']
2020-01-01     8
2020-01-02    13
Name: 可乐, dtype: int64
```

![img](.\图片\14.png)

![img](.\图片\15.png)

我们还能同时选择多列进行查看，只要把多个列名放到列表当中即可。

![img](.\图片\16.png)


并且 pandas 会按照列表中列名的顺序重新排列，结果如下：

![img](.\图片\17.png)

![img](.\图片\18.png)

**修改列**

如果我们发现表格中的数据有错误，想要修改，这其实非常的简单。和字典修改值的方式也类似，直接对已有列重新赋值即可。

![img](.\图片\19.png)

```python
>>> df['可乐']=[18, 23]
>>> df['可乐']
2020-01-01    18
2020-01-02    23
Name: 可乐, dtype: int64
```



**新增列**

如果想要新增一列同样也非常的简单，对表格中不存在的列直接赋值就能添加新的列了。

![img](.\图片\20.png)

**删除列**

删除列和字典删除元素不一样，需要用到drop()方法。我们先来看一下用法：

![img](.\图片\21.png)


drop() 方法的第一个参数是要删除的列名或索引。axis 表示针对行或列进行删除，axis = 0 表示删除对应的行，axis = 1 表示删除对应的列，axis 默认为 0。

最后的 inplace = True 表示直接修改原数据，否则 drop() 方法只是返回删除后的表格，对原表格没有影响。因此上面两种写法的结果是一样的。

![img](.\图片\22.png)


至此，我们已经学会了使用 pandas 创建一个表格。但很多情况下，我们需要的是读取表格文件进行分析。接下来我们以一个小例子来学习如何使用 pandas 导入导出表格文件，以及 pandas 中的一些常用方法。

**导入表格文件**

假设我们的电脑上有下面这样的一个表格文件，文件名为2019年销售数据.csv。

![img](.\图片\23.png)

首先我们来将其导入到 pandas 中，代码如下：

![img](.\图片\24.png)


可以看到，读取的内容是 DataFrame 类型的。我们可以根据 DataFrame 的知识对其进行一系列的操作。

读取到表格数据后，可能表格数据很多，我们想大致确认一下表格内容，不需要打印出完整的表格。这时我们可以使用 head() 方法来查看前 5 条数据。

![img](.\图片\25.png)

![img](.\图片\26.png)

head()方法还支持传入参数来控制显示前多少条数据，比如前 2 条数据：

![img](.\图片\27.png)

![img](.\图片\28.png)

除了查看开头的一些数据，还可以使用tail()方法查看末尾的数据。用法和head()一致，默认显示 5 条，可以传入参数来改变显示的条数。

![img](.\图片\29.png)

我们还能通过info()方法查看整个表格的大致信息。

![img](.\图片\30.png)

运行结果及主要含义如下图所示：

![img](.\图片\31.png)


通过 info() 方法我们可以对表格大致有个了解，知道有几行几列，以及哪列有多少条缺失数据。

除此之外，我们还能通过 describe() 方法来快速查看数据的统计摘要，方便我们对数据有一个直观上的认识。

![img](.\图片\32.png)

![img](.\图片\33.png)

生成的摘要从上往下分别表示数量、平均数、标准差、最小值、25% 50% 75% 位置的值和最大值。



**谁是销售冠军**

现在我们对数据有了大致的了解了，接下来我们来统计出谁是销售冠军。

表格中存储了每个销售员 4 个季度的销售额，我们需要对这 4 个季度的销售额进行求和，得到每个销售员这一年的销售额。

这对 pandas 来说非常的简单，只需一行代码即可完成。

![img](.\图片\34.png)

我们调用df.head()就能得到下面这样的一个表格：

![img](.\图片\35.png)


因为 DataFrame 的每一列都是一个 Series，加上 pandas 的数据对齐功能，我们可以方便便捷地得到每个销售员这一年的销售额。

我们还可以调用 max()、min()、mean()、sum() 等方法来计算最大值、最小值、平均值以及求和等。我们来看几个例子：

![img](.\图片\36.png)

![img](.\图片\37.png)

接下来我们要找到哪个销售员的总销售额最高，因此我们要用sort_values()方法对表格进行排序。

![img](.\图片\38.png)


sort_values()方法第一个参数是排序针对的列名，排序默认是升序的，因此要将 ascending 设为 False 改成降序，这样总销售额最高的会排在第一个。最后的 inplace=True 和前面的drop()方法中的 inplace 一样，表示修改原数据，否则只是返回排序后的数据，对原数据没影响。

调用df.head()我们就能看到下面这样根据总和排序好的表格了：

![img](.\图片\39.png)


可以看到，销售冠军是刘一。如果只想查看销售冠军，只要调用 df.head(1) 即可。

处理完数据后，我们还需要将数据保存下来。用 pandas 导出表格数据也很简单，只需一行代码：

![img](.\图片\40.png)

上面代码中保存的表格名和原来的表格名一样，会覆盖原来的表格。如果你想保存到新的表格文件中，只要换个不同的表格名即可。传入index=False是因为不希望将最左侧的索引保存到文件中，完整的代码如下：

![img](.\图片\41.png)

除了 csv 文件，Excel 文件也是常见的表格文件。导入导出 Excel 文件的代码是类似的，只是方法是read_excel()和to_excel()。完整代码如下：

![img](.\图片\42.png)

如果你的 Excel 文件中有多个工作表的话，还可以通过sheet_name参数指定对应的工作表，默认情况下会读取第一张工作表。比如：

![img](.\图片\43.png)
